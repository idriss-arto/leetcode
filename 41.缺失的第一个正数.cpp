/*
 * @lc app=leetcode.cn id=41 lang=cpp
 * 数组原地处理
 * [41] 缺失的第一个正数
 */

/*
 * 本题要求时间复杂度为O(N)，空间复杂度为O(1)
 * 
 * 思路一：将数组所有的数放入哈希表，随后从 1 开始依次枚举正整数，并判断其是否在哈希表中
 * 时间复杂度O(N)，空间复杂度O(N)
 * 
 * 思路二：将数组排序，然后遍历寻找缺失的第一个正数
 * 时间复杂度O(N*log(N))，空间复杂度O(1)
 * 
 * 解题思路一：
 * 考虑将给定的数组设计成哈希表的「替代产品」。
 * 假设给定数组大小为N，其中没有出现的最小正整数只能在 [1,N+1] 中。
 * 这是因为如果 [1,N] 都出现了，那么答案是 N+1，否则答案是 [1,N] 中没有出现的最小正整数。
 * 
 * 所以有以下思路：
 * 我们对数组进行遍历，对于遍历到的数 x，
 * 如果它在 [1,N] 的范围内，那么就将数组中的第 x−1 个位置（注意：数组下标从 0 开始）打上「标记」。
 * 在遍历结束之后，如果所有的位置都被打上了标记，那么答案是 N+1，否则答案是最小的没有打上标记的位置加 1。
 * 
 * 为了实现标记效果，实际解题步骤如下：
 * 1.遍历数组，将数组中所有小于等于 0 的数修改为 N+1；
 * 2.遍历数组，将绝对值小于等于N的元素的对应位置变为负数
 * 3.遍历数组，找到第一个不是负数的位置
*/

// @lc code=start
#include <vector>
#include <math.h>
using namespace std;

/* 
 * 解题思路一：
 * 考虑将给定的数组设计成哈希表的「替代产品」。
 * 假设给定数组大小为N，其中没有出现的最小正整数只能在 [1,N+1] 中。
 * 这是因为如果 [1,N] 都出现了，那么答案是 N+1，否则答案是 [1,N] 中没有出现的最小正整数。
 * 
 * 所以有以下思路：
 * 我们对数组进行遍历，对于遍历到的数 x，
 * 如果它在 [1,N] 的范围内，那么就将数组中的第 x−1 个位置（注意：数组下标从 0 开始）打上「标记」。
 * 在遍历结束之后，如果所有的位置都被打上了标记，那么答案是 N+1，否则答案是最小的没有打上标记的位置加 1。
 * 
 * 为了实现标记效果，实际解题步骤如下：
 * 1.遍历数组，将数组中所有小于等于 0 的数修改为 N+1
 * 2.遍历数组，将绝对值小于等于N的元素的对应位置变为负数
 * 3.遍历数组，找到第一个不是负数的位置
*/
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();

        //* 步骤1.遍历数组，将数组中所有小于等于 0 的数修改为 N+1
        for (int& num: nums) {
            if (num <= 0) {
                num = n + 1;
            }
        }

        //* 步骤2.遍历数组，将绝对值小于等于N的元素的对应位置变为负数
        for (int i = 0; i < n; ++i) {
            int num = abs(nums[i]);
            if (num <= n) {
                nums[num - 1] = -abs(nums[num - 1]);
            }
        }

        //* 步骤3.遍历数组，找到第一个不是负数的位置
        for (int i = 0; i < n; ++i) {
            if (nums[i] > 0) {
                return i + 1;
            }
        }

        return n + 1;
    }
};

/*
 * 解题思路二：
 * 如果数组中包含 x∈[1,N]，那么处理后，数组的第 x−1 个元素为 x。
 * 在恢复后，数组应当有 [1, 2, ..., N] 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。
 * 以题目中的示例二 [3, 4, -1, 1] 为例，恢复后的数组应当为 [1, -1, 3, 4]，我们就可以知道缺失的数为 2。
 * 
 * 实际解题步骤如下：
 * 1.对数组进行一次遍历，对于遍历到的数 x=nums[i]，如果 x∈[1,N]，我们就知道 x 应当出现在数组中的 pos(即x−1) 的位置，
 * 因此交换 nums[i] 和 nums[pos]，这样 x 就出现在了正确的位置。
 * 2.在完成交换后，新的 nums[i] 可能还在 [1,N] 的范围内，我们需要继续进行交换操作，直到 x 不属于[1,N]范围。
 ! 3.注意到上面的方法可能会陷入死循环。如果 nums[i] 恰好与 nums[pos] 相等，那么就会无限交换下去。
 * 此时我们有 nums[i] = x = nums[pos]，说明 x 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。


*/
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            if (nums[i] <= 0 || nums[i] >= n) continue;
            int pos = nums[i] - 1;
            while (nums[i] != nums[pos]) {
                swap(nums[pos], nums[i]);
                pos = nums[i] - 1;
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
};
// @lc code=end

